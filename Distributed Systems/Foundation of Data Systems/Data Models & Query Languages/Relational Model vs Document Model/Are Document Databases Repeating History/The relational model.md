The relational model laid out the data in relations ( tables ) as a collection of tuples. This made it easy to see all the data and read it based on an arbitrary condition. Inserting new rows into the tables was done w/o worrying about foreign key relationships to other tables ( I.E. possibly messing up a hardcoded access path as in the network model). Querying could also be done on keys in a column instead of needing to use those hardcoded access paths.

The *query optimizer* is responsible for executing the query and execution order, as well as deciding which indexes to use. These choices "are" the access path ( in that they're a way for the data to be found) but are not done by the application developer, and adding new functionality to querying for data is as easy as declaring a new index and the query optimizer will use whichever one is most appropriate.

The main draw of the relational model was this query optimizer w/ the core idea being that even though it was difficult to write, once you've written it any application developer can make use of it. W/o the query optimizer it's easier to hardcode access paths for certain queries but over the long term that solution doesn't have as much operability as the relational model.